# es6新特性

- let const 与 var 的区别

~~~

1: var 声明的变量有变量提升 let  const 没有
2：let 声明为变量 const 为常量
3：const 复制对象或者数组，对象与数组可以被改变便，因为const 保证的指针不变
4：let const 变量 为块级作用域
5：let const 变量不能重复
6: let const 会形成暂时性死区

~~~

- 详细介绍promise 
~~~
1：因为传统异步是通过回到函数方式结果的，为了解决回调地狱导致代码可读性差，可维护成本，所以有了promise
2: promise 三种状态 pending（进行中） resolve（已完成） reject（已拒绝）
3：promise中原型上方法 then catch  catch不会所有的错误，then 执行状态改变，then返回新的promise,then也可以执行 下一个prmise 任务。支持.then 通过链式调用完成多个异步任务
4：new Promise 中函数为同步执行  .then中函数为异步执行了
5：Promise 上静态方法：all  race resolve reject 等  
   - all 处理并发业务，所有的都成功了执行then 
   - race 多个promise 中 有一个成功了执行then 
   - resolve 将状态变为已完成
   - reject  将状态变为已拒绝

~~~

- promise 中那些是异步的那些是同步的

~~~
new promise 中函数 为同步

.then .catch 中函数为异步

~~~

- 如何解决回调地狱代码可读性差

~~~
promise
~~~

- 谈谈你对 async awiat 的理解

~~~
1: async 函数 返回值为 promie实例
2：await 只能在 async 中使用
3：async awati 同步写法异步的程序
4：await 后面需要跟 promise 实例
   - async 返回的    ----> await返回值  return
   - new Promise    -----> await 返回值 resolve实参
   - then 返回的promise ----> await 返回值 then中函数的 return

~~~

- 说一下class 的作用

~~~
是 es6中新增的class 类型
1：可以实例化对象
2: extends 继承
3：constructor 构造器，当class 类执行时候；触发constructor 狗爪槭
4：super 触发父类中的构造器
5：static 关键字可以定义，类的静态属性和静态方法
~~~


- class 中super 你是怎么应用的
~~~
1：触发父类的构造器
2：在子类中调用父类的静态方法

~~~


- es6 对象扩展有那些内容
~~~
1：解构赋值  
2：对象属性简写
3：扩展运算符
~~~


- 异步编程语言进化的过程是什么？
~~~
回调函数---> promise --->generator ---->async await
~~~

- 请说出箭头函数有什么特点

~~~
1: 匿名函数改为箭头函数
2：没有this 使用上一层中的this
3: 没有arguemets  用 rest 参数代替

~~~


## 以下程序谁线输出 为什么？

~~~js
setTimeOut(()=>{ // 宏任务
    console.log("1111")
},0)

let p = new Promise((r,j)=>{
    console.log('33333')
    r()
})
p.then(()=>{ // 微任务
    console.log('2222')
})

333

222

111

// 先同步后异步
// ....>333

// 异步中先微任务后宏任务
// ---> 222
//  --->111

~~~

请写出下面程序的输出结果，为什么？
~~~js

for(var i = 0;i<5;i++){
    setTimeout(()=>{
        console.log(i)
    },0)
}

// 5 5 5 5 5
// 因为 先同步后异步
// for 循环为同步代码，执行结束 全局变量i=5；
// 异步执行结时，使用全局变量 5 
// 所以 5个5 
~~~


~~~js
for(var i = 0;i<5;i++){
    (function(i){
        setTimeout(()=>{
            console.log(i) // 01234
    
        },0)
    })(i)
}
// 因为闭包，解决变量污染问题
// 因为立即执行函数执行5次，每次执行彼此独立不糊感染
// 异步执行的时候，访问私有变量 i
// 所以输出结果为 01234
~~~

~~~js

for(let i = 0;i<5;i++){
    setTimeout(()=>{
        console.log(i) // 0 1 2 3 4 
    },0)
}

// 因为 let  i 为块级作用域
// for循环执行多次，形成多个块级作用域
// 所以 异步在执行时候，访问自己块级作用域中i
~~~


### 判断下面this 输出结果是什么？并写出为什么？
~~~js
function a(){
    var user = "追梦子";
    console.log(this.user);  // undefine  因为a 是window触发的。window.user 为undefined 
    console.log(this); // window
}
a();
~~~

~~~js
function a(){
    var user = "追梦子";
    console.log(this.user); // undefine
    console.log(this);　　 // window 
}
window.a()
//  理由同上
~~~

~~~js
var o = {
    user:"追梦子",
    fn:function(){
        console.log(this.user); // 追梦字
        //因为fn 被 o 对象触发的
        // this==0
        // this.user===o.user == 追梦子
    }
}
o.fn();
~~~

~~~js
var o = {
    user:"追梦子",
    fn:function(){
        console.log(this.user); // 追梦子
    }
    // 理由同上
}
window.o.fn();
~~~

~~~js
var o = {
    a:10,
    b:{
        a:12,
        fn:function(){
            console.log(this.a); // 12
            // 因为fn是由b 触发的
            // 所以this==b
            // thi.a === b.a  --> 12
        }
    }
}
o.b.fn();
~~~

~~~js
var o = {
    a:10,
    b:{
        fn:function(){
            console.log(this.a);  // 10
        }
    }
    // 理由同上
}
o.b.fn();
~~~

~~~js
var o = {
    a:10,
    b:{
        fn:function(){
            console.log(this.a);  // 
        }
    }
}
o.b.fn();
~~~

~~~js
function Fn(){
    this.user = "追梦子";
}
var a = new Fn();
console.log(a.user);  //  追梦子  

// 因为 Fn 是new触发
// this 为 实例的对象 a
// 所以 a.user 为 追梦子
~~~

~~~js
function fn()  
{  
    this.user = '追梦子';  
    return {};  
}
var a = new fn;  
console.log(a.user);  // undefined
console.log(fn.user)

//  因为 return {} 
//  this 为 fn 
//  a 是 retun {} 
// 所以 a.user 为undefined

~~~

~~~js
function fn()  
{  
    this.user = '追梦子';  
    return function(){};
}
var a = new fn;  
console.log(a.user);
// 理由同上 undefined
~~~

~~~js
function fn()  
{  
    this.user = '追梦子';  
    return 1;
}
var a = new fn;  
console.log(a.user); // 追梦子
~~~

~~~JS
  var that=this;   // that ===windwo
        (function(){
            console.log(this===that)  // true
            // 因为 window触发
            // this === windwo
        })()
setTimeout(() => {
console.log(this===that)  // true
// 因为 windwo 触发
// this===window
})

~~~

~~~JS
 var obj={
            name:'hty',
            getName:function(){
                console.log(this.name)
            }
        }
        var otherObj={
            name:'hml'
        }
        var name='upupup'
        obj.getName()    //  hty
        obj.getName.call(); // upupup
        obj.getName.call(otherObj); // hml
        obj.getName.apply(); // window
        obj.getName.apply(otherObj) // hml
        obj.getName.bind(this)(); // window
        obj.getName.bind(otherObj)(); // hml

~~~


~~~JS
  var globalObject = this;
        var foo = (() => this);
        console.log(foo() === globalObject);  // true
        // 因为 foo 为箭头函数，返回值为 this  this === window
        // 所以 true
        var obj = {foo: foo};
        console.log(foo.call(obj) === globalObject);  // ture
        // 箭头函数没有 this  this 为 window 
        foo = foo.bind(obj);           
        console.log(foo() === globalObject) // true
~~~


从今天开始 直接打开浏览器 浏览器读不懂代码

>怎么让demo 运行呢？